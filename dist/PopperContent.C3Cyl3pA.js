import{g as unrefElement,u as useForwardExpose,j as computedEager}from"./useForwardExpose.Ct4MH066.js";import{P as Primitive}from"./Primitive.DurlyzDV.js";import{h as ref,k as computed,i as onMounted,d as defineComponent,l as renderSlot,J as watchPostEffect,e as createBlock,o as openBlock,w as withCtx,u as unref,K as shallowRef,s as watch,L as getCurrentScope,M as onScopeDispose,N as shallowReadonly,B as mergeDefaults,j as watchEffect,c as createElementBlock,f as createVNode,m as mergeProps,z as normalizeStyle}from"./runtime-core.esm-bundler.T-J3b-OY.js";import{c as createContext}from"./createContext.C6fsTd1r.js";function useSize(element){const size2=ref(),width=computed(()=>size2.value?.width??0),height=computed(()=>size2.value?.height??0);return onMounted(()=>{const el=unrefElement(element);if(el){size2.value={width:el.offsetWidth,height:el.offsetHeight};const resizeObserver=new ResizeObserver(entries=>{if(!Array.isArray(entries)||!entries.length)return;const entry=entries[0];let width$1,height$1;if("borderBoxSize"in entry){const borderSizeEntry=entry.borderBoxSize,borderSize=Array.isArray(borderSizeEntry)?borderSizeEntry[0]:borderSizeEntry;width$1=borderSize.inlineSize,height$1=borderSize.blockSize}else width$1=el.offsetWidth,height$1=el.offsetHeight;size2.value={width:width$1,height:height$1}});return resizeObserver.observe(el,{box:"border-box"}),()=>resizeObserver.unobserve(el)}else size2.value=void 0}),{width,height}}const[injectPopperRootContext,providePopperRootContext]=createContext("PopperRoot");var PopperRoot_vue_vue_type_script_setup_true_lang_default=defineComponent({inheritAttrs:!1,__name:"PopperRoot",setup(__props){const anchor=ref();return providePopperRootContext({anchor,onAnchorChange:element=>anchor.value=element}),(_ctx,_cache)=>renderSlot(_ctx.$slots,"default")}}),PopperRoot_default=PopperRoot_vue_vue_type_script_setup_true_lang_default,PopperAnchor_vue_vue_type_script_setup_true_lang_default=defineComponent({__name:"PopperAnchor",props:{reference:{type:null,required:!1},asChild:{type:Boolean,required:!1},as:{type:null,required:!1}},setup(__props){const props=__props,{forwardRef,currentElement}=useForwardExpose(),rootContext=injectPopperRootContext();return watchPostEffect(()=>{rootContext.onAnchorChange(props.reference??currentElement.value)}),(_ctx,_cache)=>(openBlock(),createBlock(unref(Primitive),{ref:unref(forwardRef),as:_ctx.as,"as-child":_ctx.asChild},{default:withCtx(()=>[renderSlot(_ctx.$slots,"default")]),_:3},8,["as","as-child"]))}}),PopperAnchor_default=PopperAnchor_vue_vue_type_script_setup_true_lang_default;function isNotNull(value){return value!==null}function transformOrigin(options){return{name:"transformOrigin",options,fn(data){const{placement,rects,middlewareData}=data,isArrowHidden=middlewareData.arrow?.centerOffset!==0,arrowWidth=isArrowHidden?0:options.arrowWidth,arrowHeight=isArrowHidden?0:options.arrowHeight,[placedSide,placedAlign]=getSideAndAlignFromPlacement(placement),noArrowAlign={start:"0%",center:"50%",end:"100%"}[placedAlign],arrowXCenter=(middlewareData.arrow?.x??0)+arrowWidth/2,arrowYCenter=(middlewareData.arrow?.y??0)+arrowHeight/2;let x="",y="";return placedSide==="bottom"?(x=isArrowHidden?noArrowAlign:`${arrowXCenter}px`,y=`${-arrowHeight}px`):placedSide==="top"?(x=isArrowHidden?noArrowAlign:`${arrowXCenter}px`,y=`${rects.floating.height+arrowHeight}px`):placedSide==="right"?(x=`${-arrowHeight}px`,y=isArrowHidden?noArrowAlign:`${arrowYCenter}px`):placedSide==="left"&&(x=`${rects.floating.width+arrowHeight}px`,y=isArrowHidden?noArrowAlign:`${arrowYCenter}px`),{data:{x,y}}}}}function getSideAndAlignFromPlacement(placement){const[side,align="center"]=placement.split("-");return[side,align]}const sides=["top","right","bottom","left"],min=Math.min,max=Math.max,round=Math.round,floor=Math.floor,createCoords=v=>({x:v,y:v}),oppositeSideMap={left:"right",right:"left",bottom:"top",top:"bottom"},oppositeAlignmentMap={start:"end",end:"start"};function clamp(start,value,end){return max(start,min(value,end))}function evaluate(value,param){return typeof value=="function"?value(param):value}function getSide(placement){return placement.split("-")[0]}function getAlignment(placement){return placement.split("-")[1]}function getOppositeAxis(axis){return axis==="x"?"y":"x"}function getAxisLength(axis){return axis==="y"?"height":"width"}const yAxisSides=new Set(["top","bottom"]);function getSideAxis(placement){return yAxisSides.has(getSide(placement))?"y":"x"}function getAlignmentAxis(placement){return getOppositeAxis(getSideAxis(placement))}function getAlignmentSides(placement,rects,rtl){rtl===void 0&&(rtl=!1);const alignment=getAlignment(placement),alignmentAxis=getAlignmentAxis(placement),length=getAxisLength(alignmentAxis);let mainAlignmentSide=alignmentAxis==="x"?alignment===(rtl?"end":"start")?"right":"left":alignment==="start"?"bottom":"top";return rects.reference[length]>rects.floating[length]&&(mainAlignmentSide=getOppositePlacement(mainAlignmentSide)),[mainAlignmentSide,getOppositePlacement(mainAlignmentSide)]}function getExpandedPlacements(placement){const oppositePlacement=getOppositePlacement(placement);return[getOppositeAlignmentPlacement(placement),oppositePlacement,getOppositeAlignmentPlacement(oppositePlacement)]}function getOppositeAlignmentPlacement(placement){return placement.replace(/start|end/g,alignment=>oppositeAlignmentMap[alignment])}const lrPlacement=["left","right"],rlPlacement=["right","left"],tbPlacement=["top","bottom"],btPlacement=["bottom","top"];function getSideList(side,isStart,rtl){switch(side){case"top":case"bottom":return rtl?isStart?rlPlacement:lrPlacement:isStart?lrPlacement:rlPlacement;case"left":case"right":return isStart?tbPlacement:btPlacement;default:return[]}}function getOppositeAxisPlacements(placement,flipAlignment,direction,rtl){const alignment=getAlignment(placement);let list=getSideList(getSide(placement),direction==="start",rtl);return alignment&&(list=list.map(side=>side+"-"+alignment),flipAlignment&&(list=list.concat(list.map(getOppositeAlignmentPlacement)))),list}function getOppositePlacement(placement){return placement.replace(/left|right|bottom|top/g,side=>oppositeSideMap[side])}function expandPaddingObject(padding){return{top:0,right:0,bottom:0,left:0,...padding}}function getPaddingObject(padding){return typeof padding!="number"?expandPaddingObject(padding):{top:padding,right:padding,bottom:padding,left:padding}}function rectToClientRect(rect){const{x,y,width,height}=rect;return{width,height,top:y,left:x,right:x+width,bottom:y+height,x,y}}function computeCoordsFromPlacement(_ref,placement,rtl){let{reference,floating}=_ref;const sideAxis=getSideAxis(placement),alignmentAxis=getAlignmentAxis(placement),alignLength=getAxisLength(alignmentAxis),side=getSide(placement),isVertical=sideAxis==="y",commonX=reference.x+reference.width/2-floating.width/2,commonY=reference.y+reference.height/2-floating.height/2,commonAlign=reference[alignLength]/2-floating[alignLength]/2;let coords;switch(side){case"top":coords={x:commonX,y:reference.y-floating.height};break;case"bottom":coords={x:commonX,y:reference.y+reference.height};break;case"right":coords={x:reference.x+reference.width,y:commonY};break;case"left":coords={x:reference.x-floating.width,y:commonY};break;default:coords={x:reference.x,y:reference.y}}switch(getAlignment(placement)){case"start":coords[alignmentAxis]-=commonAlign*(rtl&&isVertical?-1:1);break;case"end":coords[alignmentAxis]+=commonAlign*(rtl&&isVertical?-1:1);break}return coords}const computePosition$1=async(reference,floating,config)=>{const{placement="bottom",strategy="absolute",middleware=[],platform:platform2}=config,validMiddleware=middleware.filter(Boolean),rtl=await(platform2.isRTL==null?void 0:platform2.isRTL(floating));let rects=await platform2.getElementRects({reference,floating,strategy}),{x,y}=computeCoordsFromPlacement(rects,placement,rtl),statefulPlacement=placement,middlewareData={},resetCount=0;for(let i=0;i<validMiddleware.length;i++){const{name,fn}=validMiddleware[i],{x:nextX,y:nextY,data,reset}=await fn({x,y,initialPlacement:placement,placement:statefulPlacement,strategy,middlewareData,rects,platform:platform2,elements:{reference,floating}});x=nextX??x,y=nextY??y,middlewareData={...middlewareData,[name]:{...middlewareData[name],...data}},reset&&resetCount<=50&&(resetCount++,typeof reset=="object"&&(reset.placement&&(statefulPlacement=reset.placement),reset.rects&&(rects=reset.rects===!0?await platform2.getElementRects({reference,floating,strategy}):reset.rects),{x,y}=computeCoordsFromPlacement(rects,statefulPlacement,rtl)),i=-1)}return{x,y,placement:statefulPlacement,strategy,middlewareData}};async function detectOverflow(state,options){var _await$platform$isEle;options===void 0&&(options={});const{x,y,platform:platform2,rects,elements,strategy}=state,{boundary="clippingAncestors",rootBoundary="viewport",elementContext="floating",altBoundary=!1,padding=0}=evaluate(options,state),paddingObject=getPaddingObject(padding),element=elements[altBoundary?elementContext==="floating"?"reference":"floating":elementContext],clippingClientRect=rectToClientRect(await platform2.getClippingRect({element:(_await$platform$isEle=await(platform2.isElement==null?void 0:platform2.isElement(element)))==null||_await$platform$isEle?element:element.contextElement||await(platform2.getDocumentElement==null?void 0:platform2.getDocumentElement(elements.floating)),boundary,rootBoundary,strategy})),rect=elementContext==="floating"?{x,y,width:rects.floating.width,height:rects.floating.height}:rects.reference,offsetParent=await(platform2.getOffsetParent==null?void 0:platform2.getOffsetParent(elements.floating)),offsetScale=await(platform2.isElement==null?void 0:platform2.isElement(offsetParent))?await(platform2.getScale==null?void 0:platform2.getScale(offsetParent))||{x:1,y:1}:{x:1,y:1},elementClientRect=rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect?await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({elements,rect,offsetParent,strategy}):rect);return{top:(clippingClientRect.top-elementClientRect.top+paddingObject.top)/offsetScale.y,bottom:(elementClientRect.bottom-clippingClientRect.bottom+paddingObject.bottom)/offsetScale.y,left:(clippingClientRect.left-elementClientRect.left+paddingObject.left)/offsetScale.x,right:(elementClientRect.right-clippingClientRect.right+paddingObject.right)/offsetScale.x}}const arrow$2=options=>({name:"arrow",options,async fn(state){const{x,y,placement,rects,platform:platform2,elements,middlewareData}=state,{element,padding=0}=evaluate(options,state)||{};if(element==null)return{};const paddingObject=getPaddingObject(padding),coords={x,y},axis=getAlignmentAxis(placement),length=getAxisLength(axis),arrowDimensions=await platform2.getDimensions(element),isYAxis=axis==="y",minProp=isYAxis?"top":"left",maxProp=isYAxis?"bottom":"right",clientProp=isYAxis?"clientHeight":"clientWidth",endDiff=rects.reference[length]+rects.reference[axis]-coords[axis]-rects.floating[length],startDiff=coords[axis]-rects.reference[axis],arrowOffsetParent=await(platform2.getOffsetParent==null?void 0:platform2.getOffsetParent(element));let clientSize=arrowOffsetParent?arrowOffsetParent[clientProp]:0;(!clientSize||!await(platform2.isElement==null?void 0:platform2.isElement(arrowOffsetParent)))&&(clientSize=elements.floating[clientProp]||rects.floating[length]);const centerToReference=endDiff/2-startDiff/2,largestPossiblePadding=clientSize/2-arrowDimensions[length]/2-1,minPadding=min(paddingObject[minProp],largestPossiblePadding),maxPadding=min(paddingObject[maxProp],largestPossiblePadding),min$1=minPadding,max2=clientSize-arrowDimensions[length]-maxPadding,center=clientSize/2-arrowDimensions[length]/2+centerToReference,offset2=clamp(min$1,center,max2),shouldAddOffset=!middlewareData.arrow&&getAlignment(placement)!=null&&center!==offset2&&rects.reference[length]/2-(center<min$1?minPadding:maxPadding)-arrowDimensions[length]/2<0,alignmentOffset=shouldAddOffset?center<min$1?center-min$1:center-max2:0;return{[axis]:coords[axis]+alignmentOffset,data:{[axis]:offset2,centerOffset:center-offset2-alignmentOffset,...shouldAddOffset&&{alignmentOffset}},reset:shouldAddOffset}}}),flip$1=function(options){return options===void 0&&(options={}),{name:"flip",options,async fn(state){var _middlewareData$arrow,_middlewareData$flip;const{placement,middlewareData,rects,initialPlacement,platform:platform2,elements}=state,{mainAxis:checkMainAxis=!0,crossAxis:checkCrossAxis=!0,fallbackPlacements:specifiedFallbackPlacements,fallbackStrategy="bestFit",fallbackAxisSideDirection="none",flipAlignment=!0,...detectOverflowOptions}=evaluate(options,state);if((_middlewareData$arrow=middlewareData.arrow)!=null&&_middlewareData$arrow.alignmentOffset)return{};const side=getSide(placement),initialSideAxis=getSideAxis(initialPlacement),isBasePlacement=getSide(initialPlacement)===initialPlacement,rtl=await(platform2.isRTL==null?void 0:platform2.isRTL(elements.floating)),fallbackPlacements=specifiedFallbackPlacements||(isBasePlacement||!flipAlignment?[getOppositePlacement(initialPlacement)]:getExpandedPlacements(initialPlacement)),hasFallbackAxisSideDirection=fallbackAxisSideDirection!=="none";!specifiedFallbackPlacements&&hasFallbackAxisSideDirection&&fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement,flipAlignment,fallbackAxisSideDirection,rtl));const placements=[initialPlacement,...fallbackPlacements],overflow=await detectOverflow(state,detectOverflowOptions),overflows=[];let overflowsData=((_middlewareData$flip=middlewareData.flip)==null?void 0:_middlewareData$flip.overflows)||[];if(checkMainAxis&&overflows.push(overflow[side]),checkCrossAxis){const sides2=getAlignmentSides(placement,rects,rtl);overflows.push(overflow[sides2[0]],overflow[sides2[1]])}if(overflowsData=[...overflowsData,{placement,overflows}],!overflows.every(side2=>side2<=0)){var _middlewareData$flip2,_overflowsData$filter;const nextIndex=(((_middlewareData$flip2=middlewareData.flip)==null?void 0:_middlewareData$flip2.index)||0)+1,nextPlacement=placements[nextIndex];if(nextPlacement&&(!(checkCrossAxis==="alignment"?initialSideAxis!==getSideAxis(nextPlacement):!1)||overflowsData.every(d=>getSideAxis(d.placement)===initialSideAxis?d.overflows[0]>0:!0)))return{data:{index:nextIndex,overflows:overflowsData},reset:{placement:nextPlacement}};let resetPlacement=(_overflowsData$filter=overflowsData.filter(d=>d.overflows[0]<=0).sort((a,b)=>a.overflows[1]-b.overflows[1])[0])==null?void 0:_overflowsData$filter.placement;if(!resetPlacement)switch(fallbackStrategy){case"bestFit":{var _overflowsData$filter2;const placement2=(_overflowsData$filter2=overflowsData.filter(d=>{if(hasFallbackAxisSideDirection){const currentSideAxis=getSideAxis(d.placement);return currentSideAxis===initialSideAxis||currentSideAxis==="y"}return!0}).map(d=>[d.placement,d.overflows.filter(overflow2=>overflow2>0).reduce((acc,overflow2)=>acc+overflow2,0)]).sort((a,b)=>a[1]-b[1])[0])==null?void 0:_overflowsData$filter2[0];placement2&&(resetPlacement=placement2);break}case"initialPlacement":resetPlacement=initialPlacement;break}if(placement!==resetPlacement)return{reset:{placement:resetPlacement}}}return{}}}};function getSideOffsets(overflow,rect){return{top:overflow.top-rect.height,right:overflow.right-rect.width,bottom:overflow.bottom-rect.height,left:overflow.left-rect.width}}function isAnySideFullyClipped(overflow){return sides.some(side=>overflow[side]>=0)}const hide$1=function(options){return options===void 0&&(options={}),{name:"hide",options,async fn(state){const{rects}=state,{strategy="referenceHidden",...detectOverflowOptions}=evaluate(options,state);switch(strategy){case"referenceHidden":{const overflow=await detectOverflow(state,{...detectOverflowOptions,elementContext:"reference"}),offsets=getSideOffsets(overflow,rects.reference);return{data:{referenceHiddenOffsets:offsets,referenceHidden:isAnySideFullyClipped(offsets)}}}case"escaped":{const overflow=await detectOverflow(state,{...detectOverflowOptions,altBoundary:!0}),offsets=getSideOffsets(overflow,rects.floating);return{data:{escapedOffsets:offsets,escaped:isAnySideFullyClipped(offsets)}}}default:return{}}}}},originSides=new Set(["left","top"]);async function convertValueToCoords(state,options){const{placement,platform:platform2,elements}=state,rtl=await(platform2.isRTL==null?void 0:platform2.isRTL(elements.floating)),side=getSide(placement),alignment=getAlignment(placement),isVertical=getSideAxis(placement)==="y",mainAxisMulti=originSides.has(side)?-1:1,crossAxisMulti=rtl&&isVertical?-1:1,rawValue=evaluate(options,state);let{mainAxis,crossAxis,alignmentAxis}=typeof rawValue=="number"?{mainAxis:rawValue,crossAxis:0,alignmentAxis:null}:{mainAxis:rawValue.mainAxis||0,crossAxis:rawValue.crossAxis||0,alignmentAxis:rawValue.alignmentAxis};return alignment&&typeof alignmentAxis=="number"&&(crossAxis=alignment==="end"?alignmentAxis*-1:alignmentAxis),isVertical?{x:crossAxis*crossAxisMulti,y:mainAxis*mainAxisMulti}:{x:mainAxis*mainAxisMulti,y:crossAxis*crossAxisMulti}}const offset$1=function(options){return options===void 0&&(options=0),{name:"offset",options,async fn(state){var _middlewareData$offse,_middlewareData$arrow;const{x,y,placement,middlewareData}=state,diffCoords=await convertValueToCoords(state,options);return placement===((_middlewareData$offse=middlewareData.offset)==null?void 0:_middlewareData$offse.placement)&&(_middlewareData$arrow=middlewareData.arrow)!=null&&_middlewareData$arrow.alignmentOffset?{}:{x:x+diffCoords.x,y:y+diffCoords.y,data:{...diffCoords,placement}}}}},shift$1=function(options){return options===void 0&&(options={}),{name:"shift",options,async fn(state){const{x,y,placement}=state,{mainAxis:checkMainAxis=!0,crossAxis:checkCrossAxis=!1,limiter={fn:_ref=>{let{x:x2,y:y2}=_ref;return{x:x2,y:y2}}},...detectOverflowOptions}=evaluate(options,state),coords={x,y},overflow=await detectOverflow(state,detectOverflowOptions),crossAxis=getSideAxis(getSide(placement)),mainAxis=getOppositeAxis(crossAxis);let mainAxisCoord=coords[mainAxis],crossAxisCoord=coords[crossAxis];if(checkMainAxis){const minSide=mainAxis==="y"?"top":"left",maxSide=mainAxis==="y"?"bottom":"right",min2=mainAxisCoord+overflow[minSide],max2=mainAxisCoord-overflow[maxSide];mainAxisCoord=clamp(min2,mainAxisCoord,max2)}if(checkCrossAxis){const minSide=crossAxis==="y"?"top":"left",maxSide=crossAxis==="y"?"bottom":"right",min2=crossAxisCoord+overflow[minSide],max2=crossAxisCoord-overflow[maxSide];crossAxisCoord=clamp(min2,crossAxisCoord,max2)}const limitedCoords=limiter.fn({...state,[mainAxis]:mainAxisCoord,[crossAxis]:crossAxisCoord});return{...limitedCoords,data:{x:limitedCoords.x-x,y:limitedCoords.y-y,enabled:{[mainAxis]:checkMainAxis,[crossAxis]:checkCrossAxis}}}}}},limitShift$1=function(options){return options===void 0&&(options={}),{options,fn(state){const{x,y,placement,rects,middlewareData}=state,{offset:offset2=0,mainAxis:checkMainAxis=!0,crossAxis:checkCrossAxis=!0}=evaluate(options,state),coords={x,y},crossAxis=getSideAxis(placement),mainAxis=getOppositeAxis(crossAxis);let mainAxisCoord=coords[mainAxis],crossAxisCoord=coords[crossAxis];const rawOffset=evaluate(offset2,state),computedOffset=typeof rawOffset=="number"?{mainAxis:rawOffset,crossAxis:0}:{mainAxis:0,crossAxis:0,...rawOffset};if(checkMainAxis){const len=mainAxis==="y"?"height":"width",limitMin=rects.reference[mainAxis]-rects.floating[len]+computedOffset.mainAxis,limitMax=rects.reference[mainAxis]+rects.reference[len]-computedOffset.mainAxis;mainAxisCoord<limitMin?mainAxisCoord=limitMin:mainAxisCoord>limitMax&&(mainAxisCoord=limitMax)}if(checkCrossAxis){var _middlewareData$offse,_middlewareData$offse2;const len=mainAxis==="y"?"width":"height",isOriginSide=originSides.has(getSide(placement)),limitMin=rects.reference[crossAxis]-rects.floating[len]+(isOriginSide&&((_middlewareData$offse=middlewareData.offset)==null?void 0:_middlewareData$offse[crossAxis])||0)+(isOriginSide?0:computedOffset.crossAxis),limitMax=rects.reference[crossAxis]+rects.reference[len]+(isOriginSide?0:((_middlewareData$offse2=middlewareData.offset)==null?void 0:_middlewareData$offse2[crossAxis])||0)-(isOriginSide?computedOffset.crossAxis:0);crossAxisCoord<limitMin?crossAxisCoord=limitMin:crossAxisCoord>limitMax&&(crossAxisCoord=limitMax)}return{[mainAxis]:mainAxisCoord,[crossAxis]:crossAxisCoord}}}},size$1=function(options){return options===void 0&&(options={}),{name:"size",options,async fn(state){var _state$middlewareData,_state$middlewareData2;const{placement,rects,platform:platform2,elements}=state,{apply=()=>{},...detectOverflowOptions}=evaluate(options,state),overflow=await detectOverflow(state,detectOverflowOptions),side=getSide(placement),alignment=getAlignment(placement),isYAxis=getSideAxis(placement)==="y",{width,height}=rects.floating;let heightSide,widthSide;side==="top"||side==="bottom"?(heightSide=side,widthSide=alignment===(await(platform2.isRTL==null?void 0:platform2.isRTL(elements.floating))?"start":"end")?"left":"right"):(widthSide=side,heightSide=alignment==="end"?"top":"bottom");const maximumClippingHeight=height-overflow.top-overflow.bottom,maximumClippingWidth=width-overflow.left-overflow.right,overflowAvailableHeight=min(height-overflow[heightSide],maximumClippingHeight),overflowAvailableWidth=min(width-overflow[widthSide],maximumClippingWidth),noShift=!state.middlewareData.shift;let availableHeight=overflowAvailableHeight,availableWidth=overflowAvailableWidth;if((_state$middlewareData=state.middlewareData.shift)!=null&&_state$middlewareData.enabled.x&&(availableWidth=maximumClippingWidth),(_state$middlewareData2=state.middlewareData.shift)!=null&&_state$middlewareData2.enabled.y&&(availableHeight=maximumClippingHeight),noShift&&!alignment){const xMin=max(overflow.left,0),xMax=max(overflow.right,0),yMin=max(overflow.top,0),yMax=max(overflow.bottom,0);isYAxis?availableWidth=width-2*(xMin!==0||xMax!==0?xMin+xMax:max(overflow.left,overflow.right)):availableHeight=height-2*(yMin!==0||yMax!==0?yMin+yMax:max(overflow.top,overflow.bottom))}await apply({...state,availableWidth,availableHeight});const nextDimensions=await platform2.getDimensions(elements.floating);return width!==nextDimensions.width||height!==nextDimensions.height?{reset:{rects:!0}}:{}}}};function hasWindow(){return typeof window<"u"}function getNodeName(node){return isNode(node)?(node.nodeName||"").toLowerCase():"#document"}function getWindow(node){var _node$ownerDocument;return(node==null||(_node$ownerDocument=node.ownerDocument)==null?void 0:_node$ownerDocument.defaultView)||window}function getDocumentElement(node){var _ref;return(_ref=(isNode(node)?node.ownerDocument:node.document)||window.document)==null?void 0:_ref.documentElement}function isNode(value){return hasWindow()?value instanceof Node||value instanceof getWindow(value).Node:!1}function isElement(value){return hasWindow()?value instanceof Element||value instanceof getWindow(value).Element:!1}function isHTMLElement(value){return hasWindow()?value instanceof HTMLElement||value instanceof getWindow(value).HTMLElement:!1}function isShadowRoot(value){return!hasWindow()||typeof ShadowRoot>"u"?!1:value instanceof ShadowRoot||value instanceof getWindow(value).ShadowRoot}const invalidOverflowDisplayValues=new Set(["inline","contents"]);function isOverflowElement(element){const{overflow,overflowX,overflowY,display}=getComputedStyle$1(element);return/auto|scroll|overlay|hidden|clip/.test(overflow+overflowY+overflowX)&&!invalidOverflowDisplayValues.has(display)}const tableElements=new Set(["table","td","th"]);function isTableElement(element){return tableElements.has(getNodeName(element))}const topLayerSelectors=[":popover-open",":modal"];function isTopLayer(element){return topLayerSelectors.some(selector=>{try{return element.matches(selector)}catch{return!1}})}const transformProperties=["transform","translate","scale","rotate","perspective"],willChangeValues=["transform","translate","scale","rotate","perspective","filter"],containValues=["paint","layout","strict","content"];function isContainingBlock(elementOrCss){const webkit=isWebKit(),css=isElement(elementOrCss)?getComputedStyle$1(elementOrCss):elementOrCss;return transformProperties.some(value=>css[value]?css[value]!=="none":!1)||(css.containerType?css.containerType!=="normal":!1)||!webkit&&(css.backdropFilter?css.backdropFilter!=="none":!1)||!webkit&&(css.filter?css.filter!=="none":!1)||willChangeValues.some(value=>(css.willChange||"").includes(value))||containValues.some(value=>(css.contain||"").includes(value))}function getContainingBlock(element){let currentNode=getParentNode(element);for(;isHTMLElement(currentNode)&&!isLastTraversableNode(currentNode);){if(isContainingBlock(currentNode))return currentNode;if(isTopLayer(currentNode))return null;currentNode=getParentNode(currentNode)}return null}function isWebKit(){return typeof CSS>"u"||!CSS.supports?!1:CSS.supports("-webkit-backdrop-filter","none")}const lastTraversableNodeNames=new Set(["html","body","#document"]);function isLastTraversableNode(node){return lastTraversableNodeNames.has(getNodeName(node))}function getComputedStyle$1(element){return getWindow(element).getComputedStyle(element)}function getNodeScroll(element){return isElement(element)?{scrollLeft:element.scrollLeft,scrollTop:element.scrollTop}:{scrollLeft:element.scrollX,scrollTop:element.scrollY}}function getParentNode(node){if(getNodeName(node)==="html")return node;const result=node.assignedSlot||node.parentNode||isShadowRoot(node)&&node.host||getDocumentElement(node);return isShadowRoot(result)?result.host:result}function getNearestOverflowAncestor(node){const parentNode=getParentNode(node);return isLastTraversableNode(parentNode)?node.ownerDocument?node.ownerDocument.body:node.body:isHTMLElement(parentNode)&&isOverflowElement(parentNode)?parentNode:getNearestOverflowAncestor(parentNode)}function getOverflowAncestors(node,list,traverseIframes){var _node$ownerDocument2;list===void 0&&(list=[]),traverseIframes===void 0&&(traverseIframes=!0);const scrollableAncestor=getNearestOverflowAncestor(node),isBody=scrollableAncestor===((_node$ownerDocument2=node.ownerDocument)==null?void 0:_node$ownerDocument2.body),win=getWindow(scrollableAncestor);if(isBody){const frameElement=getFrameElement(win);return list.concat(win,win.visualViewport||[],isOverflowElement(scrollableAncestor)?scrollableAncestor:[],frameElement&&traverseIframes?getOverflowAncestors(frameElement):[])}return list.concat(scrollableAncestor,getOverflowAncestors(scrollableAncestor,[],traverseIframes))}function getFrameElement(win){return win.parent&&Object.getPrototypeOf(win.parent)?win.frameElement:null}function getCssDimensions(element){const css=getComputedStyle$1(element);let width=parseFloat(css.width)||0,height=parseFloat(css.height)||0;const hasOffset=isHTMLElement(element),offsetWidth=hasOffset?element.offsetWidth:width,offsetHeight=hasOffset?element.offsetHeight:height,shouldFallback=round(width)!==offsetWidth||round(height)!==offsetHeight;return shouldFallback&&(width=offsetWidth,height=offsetHeight),{width,height,$:shouldFallback}}function unwrapElement$1(element){return isElement(element)?element:element.contextElement}function getScale(element){const domElement=unwrapElement$1(element);if(!isHTMLElement(domElement))return createCoords(1);const rect=domElement.getBoundingClientRect(),{width,height,$}=getCssDimensions(domElement);let x=($?round(rect.width):rect.width)/width,y=($?round(rect.height):rect.height)/height;return(!x||!Number.isFinite(x))&&(x=1),(!y||!Number.isFinite(y))&&(y=1),{x,y}}const noOffsets=createCoords(0);function getVisualOffsets(element){const win=getWindow(element);return!isWebKit()||!win.visualViewport?noOffsets:{x:win.visualViewport.offsetLeft,y:win.visualViewport.offsetTop}}function shouldAddVisualOffsets(element,isFixed,floatingOffsetParent){return isFixed===void 0&&(isFixed=!1),!floatingOffsetParent||isFixed&&floatingOffsetParent!==getWindow(element)?!1:isFixed}function getBoundingClientRect(element,includeScale,isFixedStrategy,offsetParent){includeScale===void 0&&(includeScale=!1),isFixedStrategy===void 0&&(isFixedStrategy=!1);const clientRect=element.getBoundingClientRect(),domElement=unwrapElement$1(element);let scale=createCoords(1);includeScale&&(offsetParent?isElement(offsetParent)&&(scale=getScale(offsetParent)):scale=getScale(element));const visualOffsets=shouldAddVisualOffsets(domElement,isFixedStrategy,offsetParent)?getVisualOffsets(domElement):createCoords(0);let x=(clientRect.left+visualOffsets.x)/scale.x,y=(clientRect.top+visualOffsets.y)/scale.y,width=clientRect.width/scale.x,height=clientRect.height/scale.y;if(domElement){const win=getWindow(domElement),offsetWin=offsetParent&&isElement(offsetParent)?getWindow(offsetParent):offsetParent;let currentWin=win,currentIFrame=getFrameElement(currentWin);for(;currentIFrame&&offsetParent&&offsetWin!==currentWin;){const iframeScale=getScale(currentIFrame),iframeRect=currentIFrame.getBoundingClientRect(),css=getComputedStyle$1(currentIFrame),left=iframeRect.left+(currentIFrame.clientLeft+parseFloat(css.paddingLeft))*iframeScale.x,top=iframeRect.top+(currentIFrame.clientTop+parseFloat(css.paddingTop))*iframeScale.y;x*=iframeScale.x,y*=iframeScale.y,width*=iframeScale.x,height*=iframeScale.y,x+=left,y+=top,currentWin=getWindow(currentIFrame),currentIFrame=getFrameElement(currentWin)}}return rectToClientRect({width,height,x,y})}function getWindowScrollBarX(element,rect){const leftScroll=getNodeScroll(element).scrollLeft;return rect?rect.left+leftScroll:getBoundingClientRect(getDocumentElement(element)).left+leftScroll}function getHTMLOffset(documentElement,scroll){const htmlRect=documentElement.getBoundingClientRect(),x=htmlRect.left+scroll.scrollLeft-getWindowScrollBarX(documentElement,htmlRect),y=htmlRect.top+scroll.scrollTop;return{x,y}}function convertOffsetParentRelativeRectToViewportRelativeRect(_ref){let{elements,rect,offsetParent,strategy}=_ref;const isFixed=strategy==="fixed",documentElement=getDocumentElement(offsetParent),topLayer=elements?isTopLayer(elements.floating):!1;if(offsetParent===documentElement||topLayer&&isFixed)return rect;let scroll={scrollLeft:0,scrollTop:0},scale=createCoords(1);const offsets=createCoords(0),isOffsetParentAnElement=isHTMLElement(offsetParent);if((isOffsetParentAnElement||!isOffsetParentAnElement&&!isFixed)&&((getNodeName(offsetParent)!=="body"||isOverflowElement(documentElement))&&(scroll=getNodeScroll(offsetParent)),isHTMLElement(offsetParent))){const offsetRect=getBoundingClientRect(offsetParent);scale=getScale(offsetParent),offsets.x=offsetRect.x+offsetParent.clientLeft,offsets.y=offsetRect.y+offsetParent.clientTop}const htmlOffset=documentElement&&!isOffsetParentAnElement&&!isFixed?getHTMLOffset(documentElement,scroll):createCoords(0);return{width:rect.width*scale.x,height:rect.height*scale.y,x:rect.x*scale.x-scroll.scrollLeft*scale.x+offsets.x+htmlOffset.x,y:rect.y*scale.y-scroll.scrollTop*scale.y+offsets.y+htmlOffset.y}}function getClientRects(element){return Array.from(element.getClientRects())}function getDocumentRect(element){const html=getDocumentElement(element),scroll=getNodeScroll(element),body=element.ownerDocument.body,width=max(html.scrollWidth,html.clientWidth,body.scrollWidth,body.clientWidth),height=max(html.scrollHeight,html.clientHeight,body.scrollHeight,body.clientHeight);let x=-scroll.scrollLeft+getWindowScrollBarX(element);const y=-scroll.scrollTop;return getComputedStyle$1(body).direction==="rtl"&&(x+=max(html.clientWidth,body.clientWidth)-width),{width,height,x,y}}const SCROLLBAR_MAX=25;function getViewportRect(element,strategy){const win=getWindow(element),html=getDocumentElement(element),visualViewport=win.visualViewport;let width=html.clientWidth,height=html.clientHeight,x=0,y=0;if(visualViewport){width=visualViewport.width,height=visualViewport.height;const visualViewportBased=isWebKit();(!visualViewportBased||visualViewportBased&&strategy==="fixed")&&(x=visualViewport.offsetLeft,y=visualViewport.offsetTop)}const windowScrollbarX=getWindowScrollBarX(html);if(windowScrollbarX<=0){const doc=html.ownerDocument,body=doc.body,bodyStyles=getComputedStyle(body),bodyMarginInline=doc.compatMode==="CSS1Compat"&&parseFloat(bodyStyles.marginLeft)+parseFloat(bodyStyles.marginRight)||0,clippingStableScrollbarWidth=Math.abs(html.clientWidth-body.clientWidth-bodyMarginInline);clippingStableScrollbarWidth<=SCROLLBAR_MAX&&(width-=clippingStableScrollbarWidth)}else windowScrollbarX<=SCROLLBAR_MAX&&(width+=windowScrollbarX);return{width,height,x,y}}const absoluteOrFixed=new Set(["absolute","fixed"]);function getInnerBoundingClientRect(element,strategy){const clientRect=getBoundingClientRect(element,!0,strategy==="fixed"),top=clientRect.top+element.clientTop,left=clientRect.left+element.clientLeft,scale=isHTMLElement(element)?getScale(element):createCoords(1),width=element.clientWidth*scale.x,height=element.clientHeight*scale.y,x=left*scale.x,y=top*scale.y;return{width,height,x,y}}function getClientRectFromClippingAncestor(element,clippingAncestor,strategy){let rect;if(clippingAncestor==="viewport")rect=getViewportRect(element,strategy);else if(clippingAncestor==="document")rect=getDocumentRect(getDocumentElement(element));else if(isElement(clippingAncestor))rect=getInnerBoundingClientRect(clippingAncestor,strategy);else{const visualOffsets=getVisualOffsets(element);rect={x:clippingAncestor.x-visualOffsets.x,y:clippingAncestor.y-visualOffsets.y,width:clippingAncestor.width,height:clippingAncestor.height}}return rectToClientRect(rect)}function hasFixedPositionAncestor(element,stopNode){const parentNode=getParentNode(element);return parentNode===stopNode||!isElement(parentNode)||isLastTraversableNode(parentNode)?!1:getComputedStyle$1(parentNode).position==="fixed"||hasFixedPositionAncestor(parentNode,stopNode)}function getClippingElementAncestors(element,cache){const cachedResult=cache.get(element);if(cachedResult)return cachedResult;let result=getOverflowAncestors(element,[],!1).filter(el=>isElement(el)&&getNodeName(el)!=="body"),currentContainingBlockComputedStyle=null;const elementIsFixed=getComputedStyle$1(element).position==="fixed";let currentNode=elementIsFixed?getParentNode(element):element;for(;isElement(currentNode)&&!isLastTraversableNode(currentNode);){const computedStyle=getComputedStyle$1(currentNode),currentNodeIsContaining=isContainingBlock(currentNode);!currentNodeIsContaining&&computedStyle.position==="fixed"&&(currentContainingBlockComputedStyle=null),(elementIsFixed?!currentNodeIsContaining&&!currentContainingBlockComputedStyle:!currentNodeIsContaining&&computedStyle.position==="static"&&!!currentContainingBlockComputedStyle&&absoluteOrFixed.has(currentContainingBlockComputedStyle.position)||isOverflowElement(currentNode)&&!currentNodeIsContaining&&hasFixedPositionAncestor(element,currentNode))?result=result.filter(ancestor=>ancestor!==currentNode):currentContainingBlockComputedStyle=computedStyle,currentNode=getParentNode(currentNode)}return cache.set(element,result),result}function getClippingRect(_ref){let{element,boundary,rootBoundary,strategy}=_ref;const clippingAncestors=[...boundary==="clippingAncestors"?isTopLayer(element)?[]:getClippingElementAncestors(element,this._c):[].concat(boundary),rootBoundary],firstClippingAncestor=clippingAncestors[0],clippingRect=clippingAncestors.reduce((accRect,clippingAncestor)=>{const rect=getClientRectFromClippingAncestor(element,clippingAncestor,strategy);return accRect.top=max(rect.top,accRect.top),accRect.right=min(rect.right,accRect.right),accRect.bottom=min(rect.bottom,accRect.bottom),accRect.left=max(rect.left,accRect.left),accRect},getClientRectFromClippingAncestor(element,firstClippingAncestor,strategy));return{width:clippingRect.right-clippingRect.left,height:clippingRect.bottom-clippingRect.top,x:clippingRect.left,y:clippingRect.top}}function getDimensions(element){const{width,height}=getCssDimensions(element);return{width,height}}function getRectRelativeToOffsetParent(element,offsetParent,strategy){const isOffsetParentAnElement=isHTMLElement(offsetParent),documentElement=getDocumentElement(offsetParent),isFixed=strategy==="fixed",rect=getBoundingClientRect(element,!0,isFixed,offsetParent);let scroll={scrollLeft:0,scrollTop:0};const offsets=createCoords(0);function setLeftRTLScrollbarOffset(){offsets.x=getWindowScrollBarX(documentElement)}if(isOffsetParentAnElement||!isOffsetParentAnElement&&!isFixed)if((getNodeName(offsetParent)!=="body"||isOverflowElement(documentElement))&&(scroll=getNodeScroll(offsetParent)),isOffsetParentAnElement){const offsetRect=getBoundingClientRect(offsetParent,!0,isFixed,offsetParent);offsets.x=offsetRect.x+offsetParent.clientLeft,offsets.y=offsetRect.y+offsetParent.clientTop}else documentElement&&setLeftRTLScrollbarOffset();isFixed&&!isOffsetParentAnElement&&documentElement&&setLeftRTLScrollbarOffset();const htmlOffset=documentElement&&!isOffsetParentAnElement&&!isFixed?getHTMLOffset(documentElement,scroll):createCoords(0),x=rect.left+scroll.scrollLeft-offsets.x-htmlOffset.x,y=rect.top+scroll.scrollTop-offsets.y-htmlOffset.y;return{x,y,width:rect.width,height:rect.height}}function isStaticPositioned(element){return getComputedStyle$1(element).position==="static"}function getTrueOffsetParent(element,polyfill){if(!isHTMLElement(element)||getComputedStyle$1(element).position==="fixed")return null;if(polyfill)return polyfill(element);let rawOffsetParent=element.offsetParent;return getDocumentElement(element)===rawOffsetParent&&(rawOffsetParent=rawOffsetParent.ownerDocument.body),rawOffsetParent}function getOffsetParent(element,polyfill){const win=getWindow(element);if(isTopLayer(element))return win;if(!isHTMLElement(element)){let svgOffsetParent=getParentNode(element);for(;svgOffsetParent&&!isLastTraversableNode(svgOffsetParent);){if(isElement(svgOffsetParent)&&!isStaticPositioned(svgOffsetParent))return svgOffsetParent;svgOffsetParent=getParentNode(svgOffsetParent)}return win}let offsetParent=getTrueOffsetParent(element,polyfill);for(;offsetParent&&isTableElement(offsetParent)&&isStaticPositioned(offsetParent);)offsetParent=getTrueOffsetParent(offsetParent,polyfill);return offsetParent&&isLastTraversableNode(offsetParent)&&isStaticPositioned(offsetParent)&&!isContainingBlock(offsetParent)?win:offsetParent||getContainingBlock(element)||win}const getElementRects=async function(data){const getOffsetParentFn=this.getOffsetParent||getOffsetParent,getDimensionsFn=this.getDimensions,floatingDimensions=await getDimensionsFn(data.floating);return{reference:getRectRelativeToOffsetParent(data.reference,await getOffsetParentFn(data.floating),data.strategy),floating:{x:0,y:0,width:floatingDimensions.width,height:floatingDimensions.height}}};function isRTL(element){return getComputedStyle$1(element).direction==="rtl"}const platform={convertOffsetParentRelativeRectToViewportRelativeRect,getDocumentElement,getClippingRect,getOffsetParent,getElementRects,getClientRects,getDimensions,getScale,isElement,isRTL};function rectsAreEqual(a,b){return a.x===b.x&&a.y===b.y&&a.width===b.width&&a.height===b.height}function observeMove(element,onMove){let io=null,timeoutId;const root=getDocumentElement(element);function cleanup(){var _io;clearTimeout(timeoutId),(_io=io)==null||_io.disconnect(),io=null}function refresh(skip,threshold){skip===void 0&&(skip=!1),threshold===void 0&&(threshold=1),cleanup();const elementRectForRootMargin=element.getBoundingClientRect(),{left,top,width,height}=elementRectForRootMargin;if(skip||onMove(),!width||!height)return;const insetTop=floor(top),insetRight=floor(root.clientWidth-(left+width)),insetBottom=floor(root.clientHeight-(top+height)),insetLeft=floor(left),options={rootMargin:-insetTop+"px "+-insetRight+"px "+-insetBottom+"px "+-insetLeft+"px",threshold:max(0,min(1,threshold))||1};let isFirstUpdate=!0;function handleObserve(entries){const ratio=entries[0].intersectionRatio;if(ratio!==threshold){if(!isFirstUpdate)return refresh();ratio?refresh(!1,ratio):timeoutId=setTimeout(()=>{refresh(!1,1e-7)},1e3)}ratio===1&&!rectsAreEqual(elementRectForRootMargin,element.getBoundingClientRect())&&refresh(),isFirstUpdate=!1}try{io=new IntersectionObserver(handleObserve,{...options,root:root.ownerDocument})}catch{io=new IntersectionObserver(handleObserve,options)}io.observe(element)}return refresh(!0),cleanup}function autoUpdate(reference,floating,update,options){options===void 0&&(options={});const{ancestorScroll=!0,ancestorResize=!0,elementResize=typeof ResizeObserver=="function",layoutShift=typeof IntersectionObserver=="function",animationFrame=!1}=options,referenceEl=unwrapElement$1(reference),ancestors=ancestorScroll||ancestorResize?[...referenceEl?getOverflowAncestors(referenceEl):[],...getOverflowAncestors(floating)]:[];ancestors.forEach(ancestor=>{ancestorScroll&&ancestor.addEventListener("scroll",update,{passive:!0}),ancestorResize&&ancestor.addEventListener("resize",update)});const cleanupIo=referenceEl&&layoutShift?observeMove(referenceEl,update):null;let reobserveFrame=-1,resizeObserver=null;elementResize&&(resizeObserver=new ResizeObserver(_ref=>{let[firstEntry]=_ref;firstEntry&&firstEntry.target===referenceEl&&resizeObserver&&(resizeObserver.unobserve(floating),cancelAnimationFrame(reobserveFrame),reobserveFrame=requestAnimationFrame(()=>{var _resizeObserver;(_resizeObserver=resizeObserver)==null||_resizeObserver.observe(floating)})),update()}),referenceEl&&!animationFrame&&resizeObserver.observe(referenceEl),resizeObserver.observe(floating));let frameId,prevRefRect=animationFrame?getBoundingClientRect(reference):null;animationFrame&&frameLoop();function frameLoop(){const nextRefRect=getBoundingClientRect(reference);prevRefRect&&!rectsAreEqual(prevRefRect,nextRefRect)&&update(),prevRefRect=nextRefRect,frameId=requestAnimationFrame(frameLoop)}return update(),()=>{var _resizeObserver2;ancestors.forEach(ancestor=>{ancestorScroll&&ancestor.removeEventListener("scroll",update),ancestorResize&&ancestor.removeEventListener("resize",update)}),cleanupIo?.(),(_resizeObserver2=resizeObserver)==null||_resizeObserver2.disconnect(),resizeObserver=null,animationFrame&&cancelAnimationFrame(frameId)}}const offset=offset$1,shift=shift$1,flip=flip$1,size=size$1,hide=hide$1,arrow$1=arrow$2,limitShift=limitShift$1,computePosition=(reference,floating,options)=>{const cache=new Map,mergedOptions={platform,...options},platformWithCache={...mergedOptions.platform,_c:cache};return computePosition$1(reference,floating,{...mergedOptions,platform:platformWithCache})};function isComponentPublicInstance(target){return target!=null&&typeof target=="object"&&"$el"in target}function unwrapElement(target){if(isComponentPublicInstance(target)){const element=target.$el;return isNode(element)&&getNodeName(element)==="#comment"?null:element}return target}function toValue(source){return typeof source=="function"?source():unref(source)}function arrow(options){return{name:"arrow",options,fn(args){const element=unwrapElement(toValue(options.element));return element==null?{}:arrow$1({element,padding:options.padding}).fn(args)}}}function getDPR(element){return typeof window>"u"?1:(element.ownerDocument.defaultView||window).devicePixelRatio||1}function roundByDPR(element,value){const dpr=getDPR(element);return Math.round(value*dpr)/dpr}function useFloating(reference,floating,options){options===void 0&&(options={});const whileElementsMountedOption=options.whileElementsMounted,openOption=computed(()=>{var _toValue;return(_toValue=toValue(options.open))!=null?_toValue:!0}),middlewareOption=computed(()=>toValue(options.middleware)),placementOption=computed(()=>{var _toValue2;return(_toValue2=toValue(options.placement))!=null?_toValue2:"bottom"}),strategyOption=computed(()=>{var _toValue3;return(_toValue3=toValue(options.strategy))!=null?_toValue3:"absolute"}),transformOption=computed(()=>{var _toValue4;return(_toValue4=toValue(options.transform))!=null?_toValue4:!0}),referenceElement=computed(()=>unwrapElement(reference.value)),floatingElement=computed(()=>unwrapElement(floating.value)),x=ref(0),y=ref(0),strategy=ref(strategyOption.value),placement=ref(placementOption.value),middlewareData=shallowRef({}),isPositioned=ref(!1),floatingStyles=computed(()=>{const initialStyles={position:strategy.value,left:"0",top:"0"};if(!floatingElement.value)return initialStyles;const xVal=roundByDPR(floatingElement.value,x.value),yVal=roundByDPR(floatingElement.value,y.value);return transformOption.value?{...initialStyles,transform:"translate("+xVal+"px, "+yVal+"px)",...getDPR(floatingElement.value)>=1.5&&{willChange:"transform"}}:{position:strategy.value,left:xVal+"px",top:yVal+"px"}});let whileElementsMountedCleanup;function update(){if(referenceElement.value==null||floatingElement.value==null)return;const open=openOption.value;computePosition(referenceElement.value,floatingElement.value,{middleware:middlewareOption.value,placement:placementOption.value,strategy:strategyOption.value}).then(position=>{x.value=position.x,y.value=position.y,strategy.value=position.strategy,placement.value=position.placement,middlewareData.value=position.middlewareData,isPositioned.value=open!==!1})}function cleanup(){typeof whileElementsMountedCleanup=="function"&&(whileElementsMountedCleanup(),whileElementsMountedCleanup=void 0)}function attach(){if(cleanup(),whileElementsMountedOption===void 0){update();return}if(referenceElement.value!=null&&floatingElement.value!=null){whileElementsMountedCleanup=whileElementsMountedOption(referenceElement.value,floatingElement.value,update);return}}function reset(){openOption.value||(isPositioned.value=!1)}return watch([middlewareOption,placementOption,strategyOption,openOption],update,{flush:"sync"}),watch([referenceElement,floatingElement],attach,{flush:"sync"}),watch(openOption,reset,{flush:"sync"}),getCurrentScope()&&onScopeDispose(cleanup),{x:shallowReadonly(x),y:shallowReadonly(y),strategy:shallowReadonly(strategy),placement:shallowReadonly(placement),middlewareData:shallowReadonly(middlewareData),isPositioned:shallowReadonly(isPositioned),floatingStyles,update}}const PopperContentPropsDefaultValue={side:"bottom",sideOffset:0,sideFlip:!0,align:"center",alignOffset:0,alignFlip:!0,arrowPadding:0,avoidCollisions:!0,collisionBoundary:()=>[],collisionPadding:0,sticky:"partial",hideWhenDetached:!1,positionStrategy:"fixed",updatePositionStrategy:"optimized",prioritizePosition:!1},[injectPopperContentContext,providePopperContentContext]=createContext("PopperContent");var PopperContent_vue_vue_type_script_setup_true_lang_default=defineComponent({inheritAttrs:!1,__name:"PopperContent",props:mergeDefaults({side:{type:null,required:!1},sideOffset:{type:Number,required:!1},sideFlip:{type:Boolean,required:!1},align:{type:null,required:!1},alignOffset:{type:Number,required:!1},alignFlip:{type:Boolean,required:!1},avoidCollisions:{type:Boolean,required:!1},collisionBoundary:{type:null,required:!1},collisionPadding:{type:[Number,Object],required:!1},arrowPadding:{type:Number,required:!1},sticky:{type:String,required:!1},hideWhenDetached:{type:Boolean,required:!1},positionStrategy:{type:String,required:!1},updatePositionStrategy:{type:String,required:!1},disableUpdateOnLayoutShift:{type:Boolean,required:!1},prioritizePosition:{type:Boolean,required:!1},reference:{type:null,required:!1},asChild:{type:Boolean,required:!1},as:{type:null,required:!1}},{...PopperContentPropsDefaultValue}),emits:["placed"],setup(__props,{emit:__emit}){const props=__props,emits=__emit,rootContext=injectPopperRootContext(),{forwardRef,currentElement:contentElement}=useForwardExpose(),floatingRef=ref(),arrow$12=ref(),{width:arrowWidth,height:arrowHeight}=useSize(arrow$12),desiredPlacement=computed(()=>props.side+(props.align!=="center"?`-${props.align}`:"")),collisionPadding=computed(()=>typeof props.collisionPadding=="number"?props.collisionPadding:{top:0,right:0,bottom:0,left:0,...props.collisionPadding}),boundary=computed(()=>Array.isArray(props.collisionBoundary)?props.collisionBoundary:[props.collisionBoundary]),detectOverflowOptions=computed(()=>({padding:collisionPadding.value,boundary:boundary.value.filter(isNotNull),altBoundary:boundary.value.length>0})),flipOptions=computed(()=>({mainAxis:props.sideFlip,crossAxis:props.alignFlip})),computedMiddleware=computedEager(()=>[offset({mainAxis:props.sideOffset+arrowHeight.value,alignmentAxis:props.alignOffset}),props.prioritizePosition&&props.avoidCollisions&&flip({...detectOverflowOptions.value,...flipOptions.value}),props.avoidCollisions&&shift({mainAxis:!0,crossAxis:!!props.prioritizePosition,limiter:props.sticky==="partial"?limitShift():void 0,...detectOverflowOptions.value}),!props.prioritizePosition&&props.avoidCollisions&&flip({...detectOverflowOptions.value,...flipOptions.value}),size({...detectOverflowOptions.value,apply:({elements,rects,availableWidth,availableHeight})=>{const{width:anchorWidth,height:anchorHeight}=rects.reference,contentStyle=elements.floating.style;contentStyle.setProperty("--reka-popper-available-width",`${availableWidth}px`),contentStyle.setProperty("--reka-popper-available-height",`${availableHeight}px`),contentStyle.setProperty("--reka-popper-anchor-width",`${anchorWidth}px`),contentStyle.setProperty("--reka-popper-anchor-height",`${anchorHeight}px`)}}),arrow$12.value&&arrow({element:arrow$12.value,padding:props.arrowPadding}),transformOrigin({arrowWidth:arrowWidth.value,arrowHeight:arrowHeight.value}),props.hideWhenDetached&&hide({strategy:"referenceHidden",...detectOverflowOptions.value})]),reference=computed(()=>props.reference??rootContext.anchor.value),{floatingStyles,placement,isPositioned,middlewareData}=useFloating(reference,floatingRef,{strategy:props.positionStrategy,placement:desiredPlacement,whileElementsMounted:(...args)=>autoUpdate(...args,{layoutShift:!props.disableUpdateOnLayoutShift,animationFrame:props.updatePositionStrategy==="always"}),middleware:computedMiddleware}),placedSide=computed(()=>getSideAndAlignFromPlacement(placement.value)[0]),placedAlign=computed(()=>getSideAndAlignFromPlacement(placement.value)[1]);watchPostEffect(()=>{isPositioned.value&&emits("placed")});const cannotCenterArrow=computed(()=>middlewareData.value.arrow?.centerOffset!==0),contentZIndex=ref("");watchEffect(()=>{contentElement.value&&(contentZIndex.value=window.getComputedStyle(contentElement.value).zIndex)});const arrowX=computed(()=>middlewareData.value.arrow?.x??0),arrowY=computed(()=>middlewareData.value.arrow?.y??0);return providePopperContentContext({placedSide,onArrowChange:element=>arrow$12.value=element,arrowX,arrowY,shouldHideArrow:cannotCenterArrow}),(_ctx,_cache)=>(openBlock(),createElementBlock("div",{ref_key:"floatingRef",ref:floatingRef,"data-reka-popper-content-wrapper":"",style:normalizeStyle({...unref(floatingStyles),transform:unref(isPositioned)?unref(floatingStyles).transform:"translate(0, -200%)",minWidth:"max-content",zIndex:contentZIndex.value,"--reka-popper-transform-origin":[unref(middlewareData).transformOrigin?.x,unref(middlewareData).transformOrigin?.y].join(" "),...unref(middlewareData).hide?.referenceHidden&&{visibility:"hidden",pointerEvents:"none"}})},[createVNode(unref(Primitive),mergeProps({ref:unref(forwardRef)},_ctx.$attrs,{"as-child":props.asChild,as:_ctx.as,"data-side":placedSide.value,"data-align":placedAlign.value,style:{animation:unref(isPositioned)?void 0:"none"}}),{default:withCtx(()=>[renderSlot(_ctx.$slots,"default")]),_:3},16,["as-child","as","data-side","data-align","style"])],4))}}),PopperContent_default=PopperContent_vue_vue_type_script_setup_true_lang_default;export{PopperRoot_default as P,PopperContent_default as a,PopperAnchor_default as b,PopperContentPropsDefaultValue as c};
