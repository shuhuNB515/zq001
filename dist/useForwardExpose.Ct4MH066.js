import{_ as effectScope,I as onBeforeUnmount,U as getCurrentInstance,s as watch,L as getCurrentScope,M as onScopeDispose,K as shallowRef,$ as readonly,O as toValue$1,j as watchEffect,a0 as customRef,k as computed,G as isRef,P as reactive,u as unref,q as toRefs,h as ref,i as onMounted,E as nextTick}from"./runtime-core.esm-bundler.T-J3b-OY.js";function computedEager(fn,options){var _a;const result=shallowRef();return watchEffect(()=>{result.value=fn()},{...options,flush:(_a=void 0)!=null?_a:"sync"}),readonly(result)}function tryOnScopeDispose(fn){return getCurrentScope()?(onScopeDispose(fn),!0):!1}function createEventHook(){const fns=new Set,off=fn=>{fns.delete(fn)};return{on:fn=>{fns.add(fn);const offFn=()=>off(fn);return tryOnScopeDispose(offFn),{off:offFn}},off,trigger:(...args)=>Promise.all(Array.from(fns).map(fn=>fn(...args))),clear:()=>{fns.clear()}}}function createGlobalState(stateFactory){let initialized=!1,state;const scope=effectScope(!0);return(...args)=>(initialized||(state=scope.run(()=>stateFactory(...args)),initialized=!0),state)}function createSharedComposable(composable){let subscribers=0,state,scope;const dispose=()=>{subscribers-=1,scope&&subscribers<=0&&(scope.stop(),state=void 0,scope=void 0)};return(...args)=>(subscribers+=1,scope||(scope=effectScope(!0),state=scope.run(()=>composable(...args))),tryOnScopeDispose(dispose),state)}function toReactive(objectRef){if(!isRef(objectRef))return reactive(objectRef);const proxy=new Proxy({},{get(_,p,receiver){return unref(Reflect.get(objectRef.value,p,receiver))},set(_,p,value){return isRef(objectRef.value[p])&&!isRef(value)?objectRef.value[p].value=value:objectRef.value[p]=value,!0},deleteProperty(_,p){return Reflect.deleteProperty(objectRef.value,p)},has(_,p){return Reflect.has(objectRef.value,p)},ownKeys(){return Object.keys(objectRef.value)},getOwnPropertyDescriptor(){return{enumerable:!0,configurable:!0}}});return reactive(proxy)}function reactiveComputed(fn){return toReactive(computed(fn))}function reactiveOmit(obj,...keys){const flatKeys=keys.flat(),predicate=flatKeys[0];return reactiveComputed(()=>Object.fromEntries(typeof predicate=="function"?Object.entries(toRefs(obj)).filter(([k,v])=>!predicate(toValue$1(v),k)):Object.entries(toRefs(obj)).filter(e=>!flatKeys.includes(e[0]))))}const isClient=typeof window<"u"&&typeof document<"u";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const isDef=val=>typeof val<"u",toString=Object.prototype.toString,isObject=val=>toString.call(val)==="[object Object]",isIOS=getIsIOS();function getIsIOS(){var _a,_b;return isClient&&((_a=window?.navigator)==null?void 0:_a.userAgent)&&(/iP(?:ad|hone|od)/.test(window.navigator.userAgent)||((_b=window?.navigator)==null?void 0:_b.maxTouchPoints)>2&&/iPad|Macintosh/.test(window?.navigator.userAgent))}function getLifeCycleTarget(target){return getCurrentInstance()}function toArray(value){return Array.isArray(value)?value:[value]}function refAutoReset(defaultValue,afterMs=1e4){return customRef((track,trigger)=>{let value=toValue$1(defaultValue),timer;const resetAfter=()=>setTimeout(()=>{value=toValue$1(defaultValue),trigger()},toValue$1(afterMs));return tryOnScopeDispose(()=>{clearTimeout(timer)}),{get(){return track(),value},set(newValue){value=newValue,trigger(),clearTimeout(timer),timer=resetAfter()}}})}const toValue=toValue$1;function tryOnBeforeUnmount(fn,target){getLifeCycleTarget()&&onBeforeUnmount(fn,target)}function useTimeoutFn(cb,interval,options={}){const{immediate=!0,immediateCallback=!1}=options,isPending=shallowRef(!1);let timer=null;function clear(){timer&&(clearTimeout(timer),timer=null)}function stop(){isPending.value=!1,clear()}function start(...args){immediateCallback&&cb(),clear(),isPending.value=!0,timer=setTimeout(()=>{isPending.value=!1,timer=null,cb(...args)},toValue$1(interval))}return immediate&&(isPending.value=!0,isClient&&start()),tryOnScopeDispose(stop),{isPending:readonly(isPending),start,stop}}function watchImmediate(source,cb,options){return watch(source,cb,{...options,immediate:!0})}const defaultWindow=isClient?window:void 0;function unrefElement(elRef){var _a;const plain=toValue$1(elRef);return(_a=plain?.$el)!=null?_a:plain}function useEventListener(...args){const cleanups=[],cleanup=()=>{cleanups.forEach(fn=>fn()),cleanups.length=0},register=(el,event,listener,options)=>(el.addEventListener(event,listener,options),()=>el.removeEventListener(event,listener,options)),firstParamTargets=computed(()=>{const test=toArray(toValue$1(args[0])).filter(e=>e!=null);return test.every(e=>typeof e!="string")?test:void 0}),stopWatch=watchImmediate(()=>{var _a,_b;return[(_b=(_a=firstParamTargets.value)==null?void 0:_a.map(e=>unrefElement(e)))!=null?_b:[defaultWindow].filter(e=>e!=null),toArray(toValue$1(firstParamTargets.value?args[1]:args[0])),toArray(unref(firstParamTargets.value?args[2]:args[1])),toValue$1(firstParamTargets.value?args[3]:args[2])]},([raw_targets,raw_events,raw_listeners,raw_options])=>{if(cleanup(),!raw_targets?.length||!raw_events?.length||!raw_listeners?.length)return;const optionsClone=isObject(raw_options)?{...raw_options}:raw_options;cleanups.push(...raw_targets.flatMap(el=>raw_events.flatMap(event=>raw_listeners.map(listener=>register(el,event,listener,optionsClone)))))},{flush:"post"}),stop=()=>{stopWatch(),cleanup()};return tryOnScopeDispose(cleanup),stop}function useMounted(){const isMounted=shallowRef(!1),instance=getCurrentInstance();return instance&&onMounted(()=>{isMounted.value=!0},instance),isMounted}function useSupported(callback){const isMounted=useMounted();return computed(()=>(isMounted.value,!!callback()))}function createKeyPredicate(keyFilter){return typeof keyFilter=="function"?keyFilter:typeof keyFilter=="string"?event=>event.key===keyFilter:Array.isArray(keyFilter)?event=>keyFilter.includes(event.key):()=>!0}function onKeyStroke(...args){let key,handler,options={};args.length===3?(key=args[0],handler=args[1],options=args[2]):args.length===2?typeof args[1]=="object"?(key=!0,handler=args[0],options=args[1]):(key=args[0],handler=args[1]):(key=!0,handler=args[0]);const{target=defaultWindow,eventName="keydown",passive=!1,dedupe=!1}=options,predicate=createKeyPredicate(key);return useEventListener(target,eventName,e=>{e.repeat&&toValue$1(dedupe)||predicate(e)&&handler(e)},passive)}function cloneFnJSON(source){return JSON.parse(JSON.stringify(source))}function useResizeObserver(target,callback,options={}){const{window:window2=defaultWindow,...observerOptions}=options;let observer;const isSupported=useSupported(()=>window2&&"ResizeObserver"in window2),cleanup=()=>{observer&&(observer.disconnect(),observer=void 0)},targets=computed(()=>{const _targets=toValue$1(target);return Array.isArray(_targets)?_targets.map(el=>unrefElement(el)):[unrefElement(_targets)]}),stopWatch=watch(targets,els=>{if(cleanup(),isSupported.value&&window2){observer=new ResizeObserver(callback);for(const _el of els)_el&&observer.observe(_el,observerOptions)}},{immediate:!0,flush:"post"}),stop=()=>{cleanup(),stopWatch()};return tryOnScopeDispose(stop),{isSupported,stop}}function useVModel(props,key,emit,options={}){var _a,_b,_c;const{clone=!1,passive=!1,eventName,deep=!1,defaultValue,shouldEmit}=options,vm=getCurrentInstance(),_emit=emit||vm?.emit||((_a=vm?.$emit)==null?void 0:_a.bind(vm))||((_c=(_b=vm?.proxy)==null?void 0:_b.$emit)==null?void 0:_c.bind(vm?.proxy));let event=eventName;key||(key="modelValue"),event=event||`update:${key.toString()}`;const cloneFn=val=>clone?typeof clone=="function"?clone(val):cloneFnJSON(val):val,getValue2=()=>isDef(props[key])?cloneFn(props[key]):defaultValue,triggerEmit=value=>{shouldEmit?shouldEmit(value)&&_emit(event,value):_emit(event,value)};if(passive){const initialValue=getValue2(),proxy=ref(initialValue);let isUpdating=!1;return watch(()=>props[key],v=>{isUpdating||(isUpdating=!0,proxy.value=cloneFn(v),nextTick(()=>isUpdating=!1))}),watch(proxy,v=>{!isUpdating&&(v!==props[key]||deep)&&triggerEmit(v)},{deep}),proxy}else return computed({get(){return getValue2()},set(value){triggerEmit(value)}})}function useForwardExpose(){const instance=getCurrentInstance(),currentRef=ref(),currentElement=computed(()=>["#text","#comment"].includes(currentRef.value?.$el.nodeName)?currentRef.value?.$el.nextElementSibling:unrefElement(currentRef)),localExpose=Object.assign({},instance.exposed),ret={};for(const key in instance.props)Object.defineProperty(ret,key,{enumerable:!0,configurable:!0,get:()=>instance.props[key]});if(Object.keys(localExpose).length>0)for(const key in localExpose)Object.defineProperty(ret,key,{enumerable:!0,configurable:!0,get:()=>localExpose[key]});Object.defineProperty(ret,"$el",{enumerable:!0,configurable:!0,get:()=>instance.vnode.el}),instance.exposed=ret;function forwardRef(ref$1){currentRef.value=ref$1,ref$1&&(Object.defineProperty(ret,"$el",{enumerable:!0,configurable:!0,get:()=>ref$1 instanceof Element?ref$1:ref$1.$el}),instance.exposed=ret)}return{forwardRef,currentRef,currentElement}}export{useTimeoutFn as a,useVModel as b,createEventHook as c,useEventListener as d,createSharedComposable as e,reactiveOmit as f,unrefElement as g,useResizeObserver as h,isClient as i,computedEager as j,isIOS as k,createGlobalState as l,useMounted as m,defaultWindow as n,onKeyStroke as o,toValue as p,refAutoReset as r,tryOnBeforeUnmount as t,useForwardExpose as u};
