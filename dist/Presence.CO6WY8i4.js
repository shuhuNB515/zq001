import{P as inject,S as provide,U as getCurrentInstance,V as toHandlerKey,W as camelize,X as toRef,k as computed,Y as useId$1,h as ref,n as watch,L as onUnmounted,K as nextTick,d as defineComponent,C as toRefs,R as h}from"./runtime-core.esm-bundler.BnWtpekm.js";import{r as renderSlotFragments}from"./index.Dv_Oc2Px.js";import{m as defaultWindow,i as isClient,u as unrefElement}from"./useForwardExpose.D8hIQesf.js";function createContext(providerComponentName,contextName){const symbolDescription=typeof providerComponentName=="string"&&!contextName?`${providerComponentName}Context`:contextName,injectionKey=Symbol(symbolDescription);return[fallback=>{const context=inject(injectionKey,fallback);if(context||context===null)return context;throw new Error(`Injection \`${injectionKey.toString()}\` not found. Component must be used within ${Array.isArray(providerComponentName)?`one of the following components: ${providerComponentName.join(", ")}`:`\`${providerComponentName}\``}`)},contextValue=>(provide(injectionKey,contextValue),contextValue)]}function getActiveElement(){let activeElement=document.activeElement;if(activeElement==null)return null;for(;activeElement!=null&&activeElement.shadowRoot!=null&&activeElement.shadowRoot.activeElement!=null;)activeElement=activeElement.shadowRoot.activeElement;return activeElement}const[injectConfigProviderContext]=createContext("ConfigProvider");function useEmitAsProps(emit){const vm=getCurrentInstance(),events=vm?.type.emits,result={};return events?.length||console.warn(`No emitted event found. Please check component: ${vm?.type.__name}`),events?.forEach(ev=>{result[toHandlerKey(camelize(ev))]=(...arg)=>emit(ev,...arg)}),result}function useForwardProps(props){const vm=getCurrentInstance(),defaultProps=Object.keys(vm?.type.props??{}).reduce((prev,curr)=>{const defaultValue=(vm?.type.props[curr]).default;return defaultValue!==void 0&&(prev[curr]=defaultValue),prev},{}),refProps=toRef(props);return computed(()=>{const preservedProps={},assignedProps=vm?.vnode.props??{};return Object.keys(assignedProps).forEach(key=>{preservedProps[camelize(key)]=assignedProps[key]}),Object.keys({...defaultProps,...preservedProps}).reduce((prev,curr)=>(refProps.value[curr]!==void 0&&(prev[curr]=refProps.value[curr]),prev),{})})}function useForwardPropsEmits(props,emit){const parsedProps=useForwardProps(props),emitsAsProps=emit?useEmitAsProps(emit):{};return computed(()=>({...parsedProps.value,...emitsAsProps}))}function useId(deterministicId,prefix="reka"){return`${prefix}-${useId$1?.()}`}function useStateMachine(initialState,machine){const state=ref(initialState);function reducer(event){return machine[state.value][event]??state.value}return{state,dispatch:event=>{state.value=reducer(event)}}}function usePresence(present,node){const stylesRef=ref({}),prevAnimationNameRef=ref("none"),prevPresentRef=ref(present),initialState=present.value?"mounted":"unmounted";let timeoutId;const ownerWindow=node.value?.ownerDocument.defaultView??defaultWindow,{state,dispatch}=useStateMachine(initialState,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),dispatchCustomEvent=name=>{if(isClient){const customEvent=new CustomEvent(name,{bubbles:!1,cancelable:!1});node.value?.dispatchEvent(customEvent)}};watch(present,async(currentPresent,prevPresent)=>{const hasPresentChanged=prevPresent!==currentPresent;if(await nextTick(),hasPresentChanged){const prevAnimationName=prevAnimationNameRef.value,currentAnimationName=getAnimationName(node.value);currentPresent?(dispatch("MOUNT"),dispatchCustomEvent("enter"),currentAnimationName==="none"&&dispatchCustomEvent("after-enter")):currentAnimationName==="none"||currentAnimationName==="undefined"||stylesRef.value?.display==="none"?(dispatch("UNMOUNT"),dispatchCustomEvent("leave"),dispatchCustomEvent("after-leave")):prevPresent&&prevAnimationName!==currentAnimationName?(dispatch("ANIMATION_OUT"),dispatchCustomEvent("leave")):(dispatch("UNMOUNT"),dispatchCustomEvent("after-leave"))}},{immediate:!0});const handleAnimationEnd=event=>{const currentAnimationName=getAnimationName(node.value),isCurrentAnimation=currentAnimationName.includes(CSS.escape(event.animationName)),directionName=state.value==="mounted"?"enter":"leave";if(event.target===node.value&&isCurrentAnimation&&(dispatchCustomEvent(`after-${directionName}`),dispatch("ANIMATION_END"),!prevPresentRef.value)){const currentFillMode=node.value.style.animationFillMode;node.value.style.animationFillMode="forwards",timeoutId=ownerWindow?.setTimeout(()=>{node.value?.style.animationFillMode==="forwards"&&(node.value.style.animationFillMode=currentFillMode)})}event.target===node.value&&currentAnimationName==="none"&&dispatch("ANIMATION_END")},handleAnimationStart=event=>{event.target===node.value&&(prevAnimationNameRef.value=getAnimationName(node.value))},watcher=watch(node,(newNode,oldNode)=>{newNode?(stylesRef.value=getComputedStyle(newNode),newNode.addEventListener("animationstart",handleAnimationStart),newNode.addEventListener("animationcancel",handleAnimationEnd),newNode.addEventListener("animationend",handleAnimationEnd)):(dispatch("ANIMATION_END"),timeoutId!==void 0&&ownerWindow?.clearTimeout(timeoutId),oldNode?.removeEventListener("animationstart",handleAnimationStart),oldNode?.removeEventListener("animationcancel",handleAnimationEnd),oldNode?.removeEventListener("animationend",handleAnimationEnd))},{immediate:!0}),stateWatcher=watch(state,()=>{const currentAnimationName=getAnimationName(node.value);prevAnimationNameRef.value=state.value==="mounted"?currentAnimationName:"none"});return onUnmounted(()=>{watcher(),stateWatcher()}),{isPresent:computed(()=>["mounted","unmountSuspended"].includes(state.value))}}function getAnimationName(node){return node&&getComputedStyle(node).animationName||"none"}var Presence_default=defineComponent({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(props,{slots,expose}){const{present,forceMount}=toRefs(props),node=ref(),{isPresent}=usePresence(present,node);expose({present:isPresent});let children=slots.default({present:isPresent.value});children=renderSlotFragments(children||[]);const instance=getCurrentInstance();if(children&&children?.length>1){const componentName=instance?.parent?.type.name?`<${instance.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${componentName}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(line=>`  - ${line}`).join(`
`)].join(`
`))}return()=>forceMount.value||present.value||isPresent.value?h(slots.default({present:isPresent.value})[0],{ref:v=>{const el=unrefElement(v);return typeof el?.hasAttribute>"u"||(el?.hasAttribute("data-reka-popper-content-wrapper")?node.value=el.firstElementChild:node.value=el),el}}):null}});export{Presence_default as P,useForwardPropsEmits as a,useId as b,createContext as c,useEmitAsProps as d,getActiveElement as g,injectConfigProviderContext as i,useForwardProps as u};
