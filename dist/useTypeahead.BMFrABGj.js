import{i as isClient,r as refAutoReset}from"./useForwardExpose.Ct4MH066.js";import{j as watchEffect}from"./runtime-core.esm-bundler.T-J3b-OY.js";import{g as getActiveElement}from"./getActiveElement.C3iuMN-h.js";let count=0;function useFocusGuards(){watchEffect(cleanupFn=>{if(!isClient)return;const edgeGuards=document.querySelectorAll("[data-reka-focus-guard]");document.body.insertAdjacentElement("afterbegin",edgeGuards[0]??createFocusGuard()),document.body.insertAdjacentElement("beforeend",edgeGuards[1]??createFocusGuard()),count++,cleanupFn(()=>{count===1&&document.querySelectorAll("[data-reka-focus-guard]").forEach(node=>node.remove()),count--})})}function createFocusGuard(){const element=document.createElement("span");return element.setAttribute("data-reka-focus-guard",""),element.tabIndex=0,element.style.outline="none",element.style.opacity="0",element.style.position="fixed",element.style.pointerEvents="none",element}function useTypeahead(callback){const search=refAutoReset("",1e3);return{search,handleTypeaheadSearch:(key,items)=>{search.value=search.value+key;{const currentItem=getActiveElement(),itemsWithTextValue=items.map(item=>({...item,textValue:item.value?.textValue??item.ref.textContent?.trim()??""})),currentMatch=itemsWithTextValue.find(item=>item.ref===currentItem),values=itemsWithTextValue.map(item=>item.textValue),nextMatch=getNextMatch(values,search.value,currentMatch?.textValue),newItem=itemsWithTextValue.find(item=>item.textValue===nextMatch);return newItem&&newItem.ref.focus(),newItem?.ref}},resetTypeahead:()=>{search.value=""}}}function wrapArray(array,startIndex){return array.map((_,index)=>array[(startIndex+index)%array.length])}function getNextMatch(values,search,currentMatch){const normalizedSearch=search.length>1&&Array.from(search).every(char=>char===search[0])?search[0]:search,currentMatchIndex=currentMatch?values.indexOf(currentMatch):-1;let wrappedValues=wrapArray(values,Math.max(currentMatchIndex,0));normalizedSearch.length===1&&(wrappedValues=wrappedValues.filter(v=>v!==currentMatch));const nextMatch=wrappedValues.find(value=>value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));return nextMatch!==currentMatch?nextMatch:void 0}export{useTypeahead as a,useFocusGuards as u};
