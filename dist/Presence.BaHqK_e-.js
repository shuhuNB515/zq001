import{c as createContext}from"./createContext.C6fsTd1r.js";import{a1 as useId$1,h as ref,s as watch,D as onUnmounted,k as computed,E as nextTick,d as defineComponent,q as toRefs,U as getCurrentInstance,Q as h}from"./runtime-core.esm-bundler.T-J3b-OY.js";import{r as renderSlotFragments}from"./Primitive.DurlyzDV.js";import{n as defaultWindow,i as isClient,g as unrefElement}from"./useForwardExpose.Ct4MH066.js";const[injectConfigProviderContext]=createContext("ConfigProvider");function useId(deterministicId,prefix="reka"){return`${prefix}-${useId$1?.()}`}function useStateMachine(initialState,machine){const state=ref(initialState);function reducer(event){return machine[state.value][event]??state.value}return{state,dispatch:event=>{state.value=reducer(event)}}}function usePresence(present,node){const stylesRef=ref({}),prevAnimationNameRef=ref("none"),prevPresentRef=ref(present),initialState=present.value?"mounted":"unmounted";let timeoutId;const ownerWindow=node.value?.ownerDocument.defaultView??defaultWindow,{state,dispatch}=useStateMachine(initialState,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),dispatchCustomEvent=name=>{if(isClient){const customEvent=new CustomEvent(name,{bubbles:!1,cancelable:!1});node.value?.dispatchEvent(customEvent)}};watch(present,async(currentPresent,prevPresent)=>{const hasPresentChanged=prevPresent!==currentPresent;if(await nextTick(),hasPresentChanged){const prevAnimationName=prevAnimationNameRef.value,currentAnimationName=getAnimationName(node.value);currentPresent?(dispatch("MOUNT"),dispatchCustomEvent("enter"),currentAnimationName==="none"&&dispatchCustomEvent("after-enter")):currentAnimationName==="none"||currentAnimationName==="undefined"||stylesRef.value?.display==="none"?(dispatch("UNMOUNT"),dispatchCustomEvent("leave"),dispatchCustomEvent("after-leave")):prevPresent&&prevAnimationName!==currentAnimationName?(dispatch("ANIMATION_OUT"),dispatchCustomEvent("leave")):(dispatch("UNMOUNT"),dispatchCustomEvent("after-leave"))}},{immediate:!0});const handleAnimationEnd=event=>{const currentAnimationName=getAnimationName(node.value),isCurrentAnimation=currentAnimationName.includes(CSS.escape(event.animationName)),directionName=state.value==="mounted"?"enter":"leave";if(event.target===node.value&&isCurrentAnimation&&(dispatchCustomEvent(`after-${directionName}`),dispatch("ANIMATION_END"),!prevPresentRef.value)){const currentFillMode=node.value.style.animationFillMode;node.value.style.animationFillMode="forwards",timeoutId=ownerWindow?.setTimeout(()=>{node.value?.style.animationFillMode==="forwards"&&(node.value.style.animationFillMode=currentFillMode)})}event.target===node.value&&currentAnimationName==="none"&&dispatch("ANIMATION_END")},handleAnimationStart=event=>{event.target===node.value&&(prevAnimationNameRef.value=getAnimationName(node.value))},watcher=watch(node,(newNode,oldNode)=>{newNode?(stylesRef.value=getComputedStyle(newNode),newNode.addEventListener("animationstart",handleAnimationStart),newNode.addEventListener("animationcancel",handleAnimationEnd),newNode.addEventListener("animationend",handleAnimationEnd)):(dispatch("ANIMATION_END"),timeoutId!==void 0&&ownerWindow?.clearTimeout(timeoutId),oldNode?.removeEventListener("animationstart",handleAnimationStart),oldNode?.removeEventListener("animationcancel",handleAnimationEnd),oldNode?.removeEventListener("animationend",handleAnimationEnd))},{immediate:!0}),stateWatcher=watch(state,()=>{const currentAnimationName=getAnimationName(node.value);prevAnimationNameRef.value=state.value==="mounted"?currentAnimationName:"none"});return onUnmounted(()=>{watcher(),stateWatcher()}),{isPresent:computed(()=>["mounted","unmountSuspended"].includes(state.value))}}function getAnimationName(node){return node&&getComputedStyle(node).animationName||"none"}var Presence_default=defineComponent({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(props,{slots,expose}){const{present,forceMount}=toRefs(props),node=ref(),{isPresent}=usePresence(present,node);expose({present:isPresent});let children=slots.default({present:isPresent.value});children=renderSlotFragments(children||[]);const instance=getCurrentInstance();if(children&&children?.length>1){const componentName=instance?.parent?.type.name?`<${instance.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${componentName}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(line=>`  - ${line}`).join(`
`)].join(`
`))}return()=>forceMount.value||present.value||isPresent.value?h(slots.default({present:isPresent.value})[0],{ref:v=>{const el=unrefElement(v);return typeof el?.hasAttribute>"u"||(el?.hasAttribute("data-reka-popper-content-wrapper")?node.value=el.firstElementChild:node.value=el),el}}):null}});export{Presence_default as P,injectConfigProviderContext as i,useId as u};
