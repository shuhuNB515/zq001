import{k as computed,a1 as isRef,N as reactive,u as unref,p as getCurrentScope,q as onScopeDispose,C as toRefs}from"./runtime-core.esm-bundler.BnWtpekm.js";function tryOnScopeDispose(fn){return getCurrentScope()?(onScopeDispose(fn),!0):!1}function toValue(r){return typeof r=="function"?r():unref(r)}function toReactive(objectRef){if(!isRef(objectRef))return reactive(objectRef);const proxy=new Proxy({},{get(_,p,receiver){return unref(Reflect.get(objectRef.value,p,receiver))},set(_,p,value){return isRef(objectRef.value[p])&&!isRef(value)?objectRef.value[p].value=value:objectRef.value[p]=value,!0},deleteProperty(_,p){return Reflect.deleteProperty(objectRef.value,p)},has(_,p){return Reflect.has(objectRef.value,p)},ownKeys(){return Object.keys(objectRef.value)},getOwnPropertyDescriptor(){return{enumerable:!0,configurable:!0}}});return reactive(proxy)}function reactiveComputed(fn){return toReactive(computed(fn))}function reactiveOmit(obj,...keys){const flatKeys=keys.flat(),predicate=flatKeys[0];return reactiveComputed(()=>Object.fromEntries(typeof predicate=="function"?Object.entries(toRefs(obj)).filter(([k,v])=>!predicate(toValue(v),k)):Object.entries(toRefs(obj)).filter(e=>!flatKeys.includes(e[0]))))}const isClient=typeof window<"u"&&typeof document<"u";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const isDef=val=>typeof val<"u",toString=Object.prototype.toString,isObject=val=>toString.call(val)==="[object Object]",noop=()=>{};export{tryOnScopeDispose as a,isClient as b,isObject as c,isDef as i,noop as n,reactiveOmit as r,toValue as t};
