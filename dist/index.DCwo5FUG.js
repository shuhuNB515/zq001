import{am as isVNode}from"./runtime-core.esm-bundler.T-J3b-OY.js";let toastsCounter=1;var Observer=class{subscribers;toasts;dismissedToasts;constructor(){this.subscribers=[],this.toasts=[],this.dismissedToasts=new Set}subscribe=subscriber=>(this.subscribers.push(subscriber),()=>{const index=this.subscribers.indexOf(subscriber);this.subscribers.splice(index,1)});publish=data=>{this.subscribers.forEach(subscriber=>subscriber(data))};addToast=data=>{this.publish(data),this.toasts=[...this.toasts,data]};create=data=>{const{message,...rest}=data,id=typeof data.id=="number"||data.id&&data.id?.length>0?data.id:toastsCounter++,alreadyExists=this.toasts.find(toast$1=>toast$1.id===id),dismissible=data.dismissible===void 0?!0:data.dismissible;return this.dismissedToasts.has(id)&&this.dismissedToasts.delete(id),alreadyExists?this.toasts=this.toasts.map(toast$1=>toast$1.id===id?(this.publish({...toast$1,...data,id,title:message}),{...toast$1,...data,id,dismissible,title:message}):toast$1):this.addToast({title:message,...rest,dismissible,id}),id};dismiss=id=>(id?(this.dismissedToasts.add(id),requestAnimationFrame(()=>this.subscribers.forEach(subscriber=>subscriber({id,dismiss:!0})))):this.toasts.forEach(toast$1=>{this.subscribers.forEach(subscriber=>subscriber({id:toast$1.id,dismiss:!0}))}),id);message=(message,data)=>this.create({...data,message,type:"default"});error=(message,data)=>this.create({...data,type:"error",message});success=(message,data)=>this.create({...data,type:"success",message});info=(message,data)=>this.create({...data,type:"info",message});warning=(message,data)=>this.create({...data,type:"warning",message});loading=(message,data)=>this.create({...data,type:"loading",message});promise=(promise,data)=>{if(!data)return;let id;data.loading!==void 0&&(id=this.create({...data,promise,type:"loading",message:data.loading,description:typeof data.description!="function"?data.description:void 0}));const p=Promise.resolve(promise instanceof Function?promise():promise);let shouldDismiss=id!==void 0,result;const originalPromise=p.then(async response=>{if(result=["resolve",response],isVNode(response))shouldDismiss=!1,this.create({id,type:"default",message:response});else if(isHttpResponse(response)&&!response.ok){shouldDismiss=!1;const promiseData=typeof data.error=="function"?await data.error(`HTTP error! status: ${response.status}`):data.error,description=typeof data.description=="function"?await data.description(`HTTP error! status: ${response.status}`):data.description,toastSettings=typeof promiseData=="object"&&!isVNode(promiseData)?promiseData:{message:promiseData||"",id:id||""};this.create({id,type:"error",description,...toastSettings})}else if(response instanceof Error){shouldDismiss=!1;const promiseData=typeof data.error=="function"?await data.error(response):data.error,description=typeof data.description=="function"?await data.description(response):data.description,toastSettings=typeof promiseData=="object"&&!isVNode(promiseData)?promiseData:{message:promiseData||"",id:id||""};this.create({id,type:"error",description,...toastSettings})}else if(data.success!==void 0){shouldDismiss=!1;const promiseData=typeof data.success=="function"?await data.success(response):data.success,description=typeof data.description=="function"?await data.description(response):data.description,toastSettings=typeof promiseData=="object"&&!isVNode(promiseData)?promiseData:{message:promiseData||"",id:id||""};this.create({id,type:"success",description,...toastSettings})}}).catch(async error=>{if(result=["reject",error],data.error!==void 0){shouldDismiss=!1;const promiseData=typeof data.error=="function"?await data.error(error):data.error,description=typeof data.description=="function"?await data.description(error):data.description,toastSettings=typeof promiseData=="object"&&!isVNode(promiseData)?promiseData:{message:promiseData||"",id:id||""};this.create({id,type:"error",description,...toastSettings})}}).finally(()=>{shouldDismiss&&(this.dismiss(id),id=void 0),data.finally?.()}),unwrap=()=>new Promise((resolve,reject)=>originalPromise.then(()=>result[0]==="reject"?reject(result[1]):resolve(result[1])).catch(reject));return typeof id!="string"&&typeof id!="number"?{unwrap}:Object.assign(id,{unwrap})};custom=(component,data)=>{const id=data?.id||toastsCounter++,alreadyExists=this.toasts.find(toast$1=>toast$1.id===id),dismissible=data?.dismissible===void 0?!0:data.dismissible;return this.dismissedToasts.has(id)&&this.dismissedToasts.delete(id),alreadyExists?this.toasts=this.toasts.map(toast$1=>toast$1.id===id?(this.publish({...toast$1,component,dismissible,id,...data}),{...toast$1,component,dismissible,id,...data}):toast$1):this.addToast({component,dismissible,id,...data}),id};getActiveToasts=()=>this.toasts.filter(toast$1=>!this.dismissedToasts.has(toast$1.id))};const ToastState=new Observer;function toastFunction(message,data){const id=data?.id||toastsCounter++;return ToastState.create({message,id,type:"default",...data}),id}const isHttpResponse=data=>data&&typeof data=="object"&&"ok"in data&&typeof data.ok=="boolean"&&"status"in data&&typeof data.status=="number",basicToast=toastFunction,getHistory=()=>ToastState.toasts,getToasts=()=>ToastState.getActiveToasts(),toast=Object.assign(basicToast,{success:ToastState.success,info:ToastState.info,warning:ToastState.warning,error:ToastState.error,custom:ToastState.custom,message:ToastState.message,promise:ToastState.promise,dismiss:ToastState.dismiss,loading:ToastState.loading},{getHistory,getToasts});export{toast as t};
